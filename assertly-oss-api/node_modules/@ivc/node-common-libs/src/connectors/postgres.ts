import * as pg from 'pg';
import pgParseFloat from 'pg-parse-float';
import pgTmplLib from 'pg-query-template';

// parse floats in strings as floats
pgParseFloat(pg);

const pgClients: any = {};
export class Postgres {
  public pgClient: any;
  public pgTmplLib: any;
  public pgPool: any;
  public sqlTemplate: any;
  public name: string;
  private readonly context: any;

  constructor(context: any, name: string = 'business') {
    if (context.pgClient) {
      this.pgClient = context.pgClient;
    }

    this.name = name;
    this.pgTmplLib = pgTmplLib;
    this.context = context;
  }

  async init() {

    try {

      if (
        !this.context ||
        !this.context.config ||
        !this.context.config.pg ||
        !this.context.config.pg[this.name]
      ) {
        console.error('missing postgres config: ', this.context.config.pg);
        throw 'PgConnectionNullError';
      }

      const config = this.context.config.pg[this.name];

      // update pg to add pg-query-template functionality
      const pgTmplRes = pgTmplLib(pg, config);

      // expose the sqlTemplate template string function
      this.sqlTemplate = pgTmplRes.sqlTemplate;

      this.pgPool = pgTmplRes.pool;

      const client = new pg.Client(config);
      this.pgClient = pgClients[this.name] = client;

      await this.pgClient.connect();

      await this.smokeTest();
    } catch (error) {
      console.log(`Error occurred in the connection to postgres: `, error);
      throw error;
    }
  }

  smokeTest() {
    return this.pgClient.queryAsync('select 1', []);
  }
}

// get a client by name, or default if none provided;
export const getPgClient = (name = 'business') => pgClients[name];
