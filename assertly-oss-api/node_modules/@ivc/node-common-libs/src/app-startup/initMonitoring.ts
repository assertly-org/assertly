import * as metrics from 'datadog-metrics';
import tracer from 'dd-trace';
import EventEmitter from 'events';
import { loadConfig } from './configLoad';

const appConfig = loadConfig();

export const initDataDogMetrics = (config: any) => {
  metrics.init({
    host: config.http_addr + ':' + config.http_ports.business,
    prefix: config.appName + '(' + config.http_addr + ':' + config.http_ports.business + ')' + '.'
  });

  function collectMemoryStats() {
    const memUsage = process.memoryUsage();
    metrics.gauge('memory.rss', memUsage.rss);
    metrics.gauge('memory.heapTotal', memUsage.heapTotal);
    metrics.gauge('memory.heapUsed', memUsage.heapUsed);
    metrics.increment('memory.statsReported');
  }

  setInterval(collectMemoryStats, 5000);
};

export const initDistributedTracing = (serviceName: string, env?: string) => {
  tracer.init({
    debug: false,
    service: serviceName,
    env: env,
    // @ts-ignore
    logInjection: true
  });

  return tracer;
};

class ErrorEmitter extends EventEmitter {
}

export const errorEmitter = new ErrorEmitter();

export interface InitSentry {
  (config: any): void;
  filterError: (event: any, hint: any) => any;
}

export const initSentry = function (this: InitSentry, config: any) {
  let client: any = undefined;
  if (sentryEnabled()) {
    // register SentryIO
    client = require('@sentry/node');

    let subdomain = '';
    if (config.http_url && config.http_url.match(/\/\//)) {
      subdomain = (config.http_url.split(/\/\//)[1]).split('.')[0];
    }

    const clientUrl = config.errorMonitoring.sentryIO.clientUrl;

    // try to handle any global uncaught exceptions for SentryIO
    client.init({
      dsn: clientUrl,
      attachStacktrace: true,
      release: config.errorMonitoring.sentryIO.releaseHash,
      beforeSend: (event: any, hint: any) => { return this.filterError(event, hint); }
    });
    client.configureScope((scope: any) => {
      scope.setTag('subdomain', subdomain);
    });

  }

  // catch event re-fired from promise catch in apiCreator
  if (errorEmitter) {
    errorEmitter.on('caughtGlobalException', function (err: any, wrapper: any) {
      console.warn('caughtGlobalException', err);
      if (sentryEnabled())
        sendErrorToSentry(err, wrapper);
    });
  }

  // catch unhandled global event fired from Bluebird
  process.on('unhandledRejection', function (err, wrapper) {
    console.warn('unhandledRejection', err);
    if (sentryEnabled())
      sendErrorToSentry(err, wrapper);
  });

  function sendErrorToSentry(err: any, wrapper: any) {
    if (wrapper) {
      if (wrapper.req !== undefined) {
        delete wrapper.req.session.user_info.shared['email'];
        delete wrapper.req.session.user_info.shared['last_name'];
        client.configureScope((scope: any) => {
          scope.setExtra('session', wrapper.req.session);
          scope.setExtra('headers', wrapper.req.headers);
          scope.setExtra('url', wrapper.req.url);
          scope.setExtra('method', wrapper.req.method);
          scope.setExtra('originalUrl', wrapper.req.originalUrl);
          scope.setExtra('route', wrapper.req.route);
          scope.setExtra('reqQuery', wrapper.req.query);
          scope.setExtra('reqBody', wrapper.req.body);
        });
      }

      if (wrapper.input !== undefined) {
        client.configureScope((scope: any) => {
          scope.setExtra('input', wrapper.input);
        });
      }
    }

    client.captureException(err);
  }

  function sentryEnabled() {
    if (
      config.errorMonitoring &&
      config.errorMonitoring.sentryIO &&
      config.errorMonitoring.sentryIO.enabled === true
    ) {
      return true;
    }

    return false;
  }

  interface SentryError {
    [key: string]: any;
    expiredTimeStamp: Date;
  }

  const loggedErrors: SentryError[] = [];
  this.filterError = (event: any, hint: any): any => {
    const { response } = hint.originalException;
    if (!response || isHighPriorityError(response.statusCode) == false) {
        return event;
    }

    if (needSendHighPriorityError(response)) {
      setEventTag(event, 'highPriority', true);
      return event;
    }

    return null;// tslint:disable-line
  };

  function setEventTag(event: any, key: string, value: any) {
    if (!event.tags) {
      event.tags = {};
    }

    event.tags[key] = value;
  }

  function isHighPriorityError(statusCode: number): boolean {
    if (
      config.errorMonitoring &&
      config.errorMonitoring.sentryIO &&
      config.errorMonitoring.sentryIO.highPriorityErrorResponseStatusCodes &&
      config.errorMonitoring.sentryIO.highPriorityErrorResponseStatusCodes.indexOf(statusCode) >= 0
    ) {
      return true;
    }

    return false;
  }

  function needSendHighPriorityError(response: any): boolean {
    if (!response || isHighPriorityError(response.statusCode) == false) {
      return false;
    }

    const { request } = response;
    if (!request) {
      return false;
    }

    const errorKey = request.url;
    const loggedError = loggedErrors[errorKey];
    if (loggedError && loggedError.expiredTimeStamp > new Date()) {
      return false;
    }

    let expiredTimeStampSpanInSeconds = appConfig.errorMonitoring.defaultExpiredTimeStampSpanInSeconds;
    if (
        config.errorMonitoring &&
        config.errorMonitoring.sentryIO &&
        config.errorMonitoring.sentryIO.expiredTimeStampSpanInSeconds
    ) {
        expiredTimeStampSpanInSeconds = config.errorMonitoring.sentryIO.expiredTimeStampSpanInSeconds;
    }

    const expiredTimeStamp = new Date();
    expiredTimeStamp.setSeconds(expiredTimeStamp.getSeconds() + expiredTimeStampSpanInSeconds);
    loggedErrors[errorKey] = { expiredTimeStamp: expiredTimeStamp };

    return true;
  }
} as any as { new (config: any): InitSentry; };