{"version":3,"file":"baseclient.js","sourceRoot":"","sources":["../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scope } from '@sentry/hub';\nimport {\n  Breadcrumb,\n  Integration,\n  IntegrationClass,\n  SdkInfo,\n  SentryBreadcrumbHint,\n  SentryEvent,\n  SentryEventHint,\n  SentryResponse,\n  Severity,\n  Status,\n} from '@sentry/types';\nimport { forget } from '@sentry/utils/async';\nimport { isPrimitive } from '@sentry/utils/is';\nimport { logger } from '@sentry/utils/logger';\nimport { consoleSandbox, uuid4 } from '@sentry/utils/misc';\nimport { truncate } from '@sentry/utils/string';\nimport { BackendClass } from './basebackend';\nimport { Dsn } from './dsn';\nimport { IntegrationIndex, setupIntegrations } from './integration';\nimport { Backend, Client, Options } from './interfaces';\nimport { PromiseBuffer } from './promisebuffer';\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 30;\n\n/**\n * Absolute maximum number of breadcrumbs added to an event. The\n * `maxBreadcrumbs` option cannot be higher than this value.\n */\nconst MAX_BREADCRUMBS = 100;\n\n/**\n * By default, truncates URL values to 250 chars\n */\nconst MAX_URL_LENGTH = 250;\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the enviornment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  private readonly backend: B;\n\n  /** Options passed to the SDK. */\n  private readonly options: O;\n\n  /**\n   * The client Dsn, if specified in options. Without this Dsn, the SDK will be\n   * disabled.\n   */\n  private readonly dsn?: Dsn;\n\n  /**\n   * Stores whether installation has been performed and was successful. Before\n   * installing, this is undefined. Then it contains the success state.\n   */\n  private installed?: boolean;\n\n  /** Array of used integrations. */\n  private readonly integrations: IntegrationIndex;\n\n  /** A simple buffer holding all requests. */\n  protected readonly buffer: PromiseBuffer<SentryResponse> = new PromiseBuffer();\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this.backend = new backendClass(options);\n    this.options = options;\n\n    if (options.dsn) {\n      this.dsn = new Dsn(options.dsn);\n    }\n    // We have to setup the integrations in the constructor since we do not want\n    // that anyone needs to call client.install();\n    this.integrations = setupIntegrations(this.options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public install(): boolean {\n    if (!this.isEnabled()) {\n      return (this.installed = false);\n    }\n\n    const backend = this.getBackend();\n    if (!this.installed && backend.install) {\n      backend.install();\n    }\n\n    return (this.installed = true);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureException(exception: any, hint?: SentryEventHint, scope?: Scope): Promise<SentryResponse> {\n    return this.buffer.add(\n      (async () => {\n        const event = await this.getBackend().eventFromException(exception, hint);\n        return this.captureEvent(event, hint, scope);\n      })(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureMessage(\n    message: string,\n    level?: Severity,\n    hint?: SentryEventHint,\n    scope?: Scope,\n  ): Promise<SentryResponse> {\n    return this.buffer.add(\n      (async () => {\n        const event = isPrimitive(message)\n          ? await this.getBackend().eventFromMessage(`${message}`, level, hint)\n          : await this.getBackend().eventFromException(message, hint);\n\n        return this.captureEvent(event, hint, scope);\n      })(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureEvent(event: SentryEvent, hint?: SentryEventHint, scope?: Scope): Promise<SentryResponse> {\n    // Adding this here is technically not correct since if you call captureMessage/captureException it's already\n    // buffered. But since we not really need the count and we only need to know if the buffer is full or not,\n    // This is fine...\n    return this.buffer.add(\n      (async () =>\n        this.processEvent(event, async finalEvent => this.getBackend().sendEvent(finalEvent), hint, scope))(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, hint?: SentryBreadcrumbHint, scope?: Scope): void {\n    const { beforeBreadcrumb, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = this.getOptions();\n\n    if (maxBreadcrumbs <= 0) {\n      return;\n    }\n\n    const timestamp = new Date().getTime() / 1000;\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    const finalBreadcrumb = beforeBreadcrumb\n      ? (consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) as Breadcrumb | null)\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) {\n      return;\n    }\n\n    if (this.getBackend().storeBreadcrumb(finalBreadcrumb) && scope) {\n      scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): Dsn | undefined {\n    return this.dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this.options;\n  }\n\n  /** Returns the current backend. */\n  protected getBackend(): B {\n    return this.backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this.dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional informartion about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected async prepareEvent(event: SentryEvent, scope?: Scope, hint?: SentryEventHint): Promise<SentryEvent | null> {\n    const { environment, maxBreadcrumbs = DEFAULT_BREADCRUMBS, release, dist } = this.getOptions();\n\n    const prepared = { ...event };\n    if (prepared.environment === undefined && environment !== undefined) {\n      prepared.environment = environment;\n    }\n    if (prepared.release === undefined && release !== undefined) {\n      prepared.release = release;\n    }\n\n    if (prepared.dist === undefined && dist !== undefined) {\n      prepared.dist = dist;\n    }\n\n    if (prepared.message) {\n      prepared.message = truncate(prepared.message, MAX_URL_LENGTH);\n    }\n\n    const exception = prepared.exception && prepared.exception.values && prepared.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, MAX_URL_LENGTH);\n    }\n\n    const request = prepared.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, MAX_URL_LENGTH);\n    }\n\n    if (prepared.event_id === undefined) {\n      prepared.event_id = uuid4();\n    }\n\n    this._addIntegrations(prepared.sdk);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (scope) {\n      return scope.applyToEvent(prepared, hint, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));\n    }\n\n    return prepared;\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n  protected _addIntegrations(sdkInfo?: SdkInfo): void {\n    const integrationsArray = Object.keys(this.integrations);\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   * The returned event status offers clues to whether the event was sent to\n   * Sentry and accepted there. If the {@link Options.shouldSend} hook returns\n   * `false`, the status will be {@link SendStatus.Skipped}. If the rate limit\n   * was exceeded, the status will be {@link SendStatus.RateLimit}.\n   *\n   * @param event The event to send to Sentry.\n   * @param send A function to actually send the event.\n   * @param scope A scope containing event metadata.\n   * @param hint May contain additional informartion about the original exception.\n   * @returns A Promise that resolves with the event status.\n   */\n  protected async processEvent(\n    event: SentryEvent,\n    send: (finalEvent: SentryEvent) => Promise<SentryResponse>,\n    hint?: SentryEventHint,\n    scope?: Scope,\n  ): Promise<SentryResponse> {\n    if (!this.isEnabled()) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    if (typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    const prepared = await this.prepareEvent(event, scope, hint);\n    if (prepared === null) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    let finalEvent: SentryEvent | null = prepared;\n\n    try {\n      const isInternalException = hint && hint.data && (hint.data as { [key: string]: any }).__sentry__ === true;\n      if (!isInternalException && beforeSend) {\n        finalEvent = await beforeSend(prepared, hint);\n        if ((typeof finalEvent as any) === 'undefined') {\n          logger.error('`beforeSend` method has to return `null` or a valid event');\n        }\n      }\n    } catch (exception) {\n      forget(\n        this.captureException(exception, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: exception as Error,\n        }),\n      );\n\n      return {\n        reason: 'Event processing in beforeSend method threw an exception',\n        status: Status.Invalid,\n      };\n    }\n\n    if (finalEvent === null) {\n      return {\n        reason: 'Event dropped due to being discarded by beforeSend method',\n        status: Status.Skipped,\n      };\n    }\n\n    try {\n      const response = await send(finalEvent);\n      response.event = finalEvent;\n\n      if (response.status === Status.RateLimit) {\n        // TODO: Handle rate limits and maintain a queue. For now, we require SDK\n        // implementors to override this method and handle it themselves.\n      }\n      return response;\n    } catch (error) {\n      // We have a catch here since the transport can reject the request internally.\n      // If we do not catch this here, we will run into an endless loop.\n      logger.error(`${error}`);\n      return {\n        reason: `${error}`,\n        status: Status.Failed,\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async flush(timeout?: number): Promise<boolean> {\n    return (await Promise.all([\n      this.getBackend()\n        .getTransport()\n        .close(timeout),\n      this.buffer.drain(timeout),\n    ])).reduce((prev, current) => prev && current);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async close(timeout?: number): Promise<boolean> {\n    return this.flush(timeout);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegrations(): IntegrationIndex {\n    return this.integrations || {};\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this.integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n}\n"]}