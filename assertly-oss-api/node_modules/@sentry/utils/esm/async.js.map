{"version":3,"file":"async.js","sourceRoot":"","sources":["../src/async.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,MAAM,UAAU,MAAM,CAAC,OAAqB;IAC1C,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QAChB,uCAAuC;QACvC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,KAAU,EACV,SAAkD,EAClD,OAAa;IAEb,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;IAClE,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AACrD,CAAC","sourcesContent":["/**\n * Consumes the promise and logs the error when it rejects.\n * @param promise A promise to forget.\n */\nexport function forget(promise: Promise<any>): void {\n  promise.catch(e => {\n    // TODO: Use a better logging mechanism\n    console.error(e);\n  });\n}\n\n/**\n * Helper to filter an array with asynchronous callbacks.\n *\n * @param array An array containing items to filter.\n * @param predicate An async predicate evaluated on every item.\n * @param thisArg Optional value passed as \"this\" into the callback.\n * @returns An array containing only values where the callback returned true.\n */\nexport async function filterAsync<T>(\n  array: T[],\n  predicate: (item: T) => Promise<boolean> | boolean,\n  thisArg?: any,\n): Promise<T[]> {\n  const verdicts = await Promise.all(array.map(predicate, thisArg));\n  return array.filter((_, index) => verdicts[index]);\n}\n"]}